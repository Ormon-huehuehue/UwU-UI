{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "marquee-along-svg-path",
  "type": "registry:ui",
  "dependencies": [
    "motion"
  ],
  "author": "daniel petho <https://www.danielpetho.com>",
  "registryDependencies": [
    "https://uwuui.com/r/utils.json"
  ],
  "files": [
    {
      "path": "fancy/blocks/marquee-along-svg-path.tsx",
      "content": "import React, { RefObject, useCallback, useEffect, useRef } from \"react\"\nimport {\n  motion,\n  SpringOptions,\n  useAnimationFrame,\n  useMotionValue,\n  useScroll,\n  useSpring,\n  useTransform,\n  useVelocity,\n} from \"motion/react\"\n\nimport { cn } from \"@/lib/utils\"\n\n// Custom wrap function\nconst wrap = (min: number, max: number, value: number): number => {\n  const range = max - min\n  return ((((value - min) % range) + range) % range) + min\n}\n\ntype PreserveAspectRatioAlign =\n  | \"none\"\n  | \"xMinYMin\"\n  | \"xMidYMin\"\n  | \"xMaxYMin\"\n  | \"xMinYMid\"\n  | \"xMidYMid\"\n  | \"xMaxYMid\"\n  | \"xMinYMax\"\n  | \"xMidYMax\"\n  | \"xMaxYMax\"\n\ninterface CSSVariableInterpolation {\n  property: string\n  from: number | string\n  to: number | string\n}\n\ntype PreserveAspectRatioMeetOrSlice = \"meet\" | \"slice\"\n\ntype PreserveAspectRatio =\n  | PreserveAspectRatioAlign\n  | `${Exclude<PreserveAspectRatioAlign, \"none\">} ${PreserveAspectRatioMeetOrSlice}`\n\ninterface MarqueeAlongSvgPathProps {\n  children: React.ReactNode\n  className?: string\n\n  // Path properties\n  path: string\n  pathId?: string\n  preserveAspectRatio?: PreserveAspectRatio\n  showPath?: boolean\n\n  // SVG properties\n  width?: string | number\n  height?: string | number\n  viewBox?: string\n\n  // Marquee properties\n  baseVelocity?: number\n  direction?: \"normal\" | \"reverse\"\n  easing?: (value: number) => number\n  slowdownOnHover?: boolean\n  slowDownFactor?: number\n  slowDownSpringConfig?: SpringOptions\n\n  // Scroll properties\n  useScrollVelocity?: boolean\n  scrollAwareDirection?: boolean\n  scrollSpringConfig?: SpringOptions\n  scrollContainer?: RefObject<HTMLElement> | HTMLElement | null\n\n  // Item repetition\n  repeat?: number\n\n  // Drag properties\n  draggable?: boolean\n  dragSensitivity?: number\n  dragVelocityDecay?: number\n  dragAwareDirection?: boolean\n  grabCursor?: boolean\n\n  // Z-index properties\n  enableRollingZIndex?: boolean\n  zIndexBase?: number\n  zIndexRange?: number\n\n  cssVariableInterpolation?: CSSVariableInterpolation[]\n}\n\nconst MarqueeAlongSvgPath = ({\n  children,\n  className,\n\n  // Path defaults\n  path,\n  pathId,\n  preserveAspectRatio = \"xMidYMid meet\",\n  showPath = false,\n\n  // SVG defaults\n  width = \"100%\",\n  height = \"100%\",\n  viewBox = \"0 0 100 100\",\n\n  // Marquee defaults\n  baseVelocity = 5,\n  direction = \"normal\",\n  easing,\n  slowdownOnHover = false,\n  slowDownFactor = 0.3,\n  slowDownSpringConfig = { damping: 50, stiffness: 400 },\n\n  // Scroll defaults\n  useScrollVelocity = false,\n  scrollAwareDirection = false,\n  scrollSpringConfig = { damping: 50, stiffness: 400 },\n  scrollContainer,\n\n  // Items repetition\n  repeat = 3,\n\n  // Drag defaults\n  draggable = false,\n  dragSensitivity = 0.2,\n  dragVelocityDecay = 0.96,\n  dragAwareDirection = false,\n  grabCursor = false,\n\n  // Z-index defaults\n  enableRollingZIndex = true,\n  zIndexBase = 1, // Base z-index value\n  zIndexRange = 10, // Range of z-index values to use\n\n  cssVariableInterpolation = [],\n}: MarqueeAlongSvgPathProps) => {\n  const container = useRef<HTMLDivElement>(null)\n  const baseOffset = useMotionValue(0)\n\n  const pathRef = useRef<SVGPathElement>(null)\n\n  const itemRefs = useRef<Map<string, HTMLDivElement>>(new Map())\n\n  // Create an array of items outside of the render function\n  const items = React.useMemo(() => {\n    const childrenArray = React.Children.toArray(children)\n\n    return childrenArray.flatMap((child, childIndex) =>\n      Array.from({ length: repeat }, (_, repeatIndex) => {\n        const itemIndex = repeatIndex * childrenArray.length + childIndex\n        const key = `${childIndex}-${repeatIndex}`\n        return {\n          child,\n          childIndex,\n          repeatIndex,\n          itemIndex,\n          key,\n        }\n      })\n    )\n  }, [children, repeat])\n\n  // Function to calculate z-index based on offset distance\n  const calculateZIndex = useCallback(\n    (offsetDistance: number) => {\n      if (!enableRollingZIndex) {\n        return undefined\n      }\n\n      // Simple progress-based z-index\n      const normalizedDistance = offsetDistance / 100\n      return Math.floor(zIndexBase + normalizedDistance * zIndexRange)\n    },\n    [enableRollingZIndex, zIndexBase, zIndexRange]\n  )\n\n  // Generate a random ID for the path if not provided\n  const id = pathId || `marquee-path-${Math.random().toString(36).substring(7)}`\n\n  // Scroll tracking\n  const { scrollY } = useScroll({\n    container: (scrollContainer as RefObject<HTMLDivElement>) || container,\n  })\n\n  const scrollVelocity = useVelocity(scrollY)\n  const smoothVelocity = useSpring(scrollVelocity, scrollSpringConfig)\n\n  // Hover and drag state tracking\n  const isHovered = useRef(false)\n  const isDragging = useRef(false)\n  const dragVelocity = useRef(0)\n\n  // Direction factor for changing direction based on scroll or drag\n  const directionFactor = useRef(direction === \"normal\" ? 1 : -1)\n\n  // Motion values for animation\n  const hoverFactorValue = useMotionValue(1)\n  const defaultVelocity = useMotionValue(1)\n  const smoothHoverFactor = useSpring(hoverFactorValue, slowDownSpringConfig)\n\n  // Transform scroll velocity into a factor that affects marquee speed\n  const velocityFactor = useTransform(\n    useScrollVelocity ? smoothVelocity : defaultVelocity,\n    [0, 1000],\n    [0, 5],\n    { clamp: false }\n  )\n\n  // Animation frame handler\n  useAnimationFrame((_, delta) => {\n    if (isDragging.current && draggable) {\n      baseOffset.set(baseOffset.get() + dragVelocity.current)\n\n      // Add decay to dragVelocity\n      dragVelocity.current *= 0.9\n\n      // Stop completely if velocity is very small\n      if (Math.abs(dragVelocity.current) < 0.01) {\n        dragVelocity.current = 0\n      }\n\n      return\n    }\n\n    // Update hover factor\n    if (isHovered.current) {\n      hoverFactorValue.set(slowdownOnHover ? slowDownFactor : 1)\n    } else {\n      hoverFactorValue.set(1)\n    }\n\n    // Calculate regular movement\n    let moveBy =\n      directionFactor.current *\n      baseVelocity *\n      (delta / 1000) *\n      smoothHoverFactor.get()\n\n    // Adjust movement based on scroll velocity if scrollAwareDirection is enabled\n    if (scrollAwareDirection && !isDragging.current) {\n      if (velocityFactor.get() < 0) {\n        directionFactor.current = -1\n      } else if (velocityFactor.get() > 0) {\n        directionFactor.current = 1\n      }\n    }\n\n    moveBy += directionFactor.current * moveBy * velocityFactor.get()\n\n    if (draggable) {\n      moveBy += dragVelocity.current\n\n      // Update direction based on drag direction if dragAwareDirection is true\n      if (dragAwareDirection && Math.abs(dragVelocity.current) > 0.1) {\n        directionFactor.current = Math.sign(dragVelocity.current)\n      }\n\n      // Gradually decay drag velocity back to zero\n      if (!isDragging.current && Math.abs(dragVelocity.current) > 0.01) {\n        dragVelocity.current *= dragVelocityDecay\n      } else if (!isDragging.current) {\n        dragVelocity.current = 0\n      }\n    }\n\n    baseOffset.set(baseOffset.get() + moveBy)\n  })\n\n  // Pointer event handlers for dragging\n  const lastPointerPosition = useRef({ x: 0, y: 0 })\n\n  const handlePointerDown = (e: React.PointerEvent) => {\n    if (!draggable) return\n    ;(e.currentTarget as HTMLElement).setPointerCapture(e.pointerId)\n\n    if (grabCursor) {\n      ;(e.currentTarget as HTMLElement).style.cursor = \"grabbing\"\n    }\n\n    isDragging.current = true\n    lastPointerPosition.current = { x: e.clientX, y: e.clientY }\n\n    // Pause automatic animation by setting velocity to 0\n    dragVelocity.current = 0\n  }\n\n  const handlePointerMove = (e: React.PointerEvent) => {\n    if (!draggable || !isDragging.current) return\n\n    const currentPosition = { x: e.clientX, y: e.clientY }\n\n    // Calculate movement delta - simplified for path movement\n    const deltaX = currentPosition.x - lastPointerPosition.current.x\n    const deltaY = currentPosition.y - lastPointerPosition.current.y\n\n    // For path following, we use a simple magnitude of movement\n    const delta = Math.sqrt(deltaX * deltaX + deltaY * deltaY)\n    const projectedDelta = deltaX > 0 ? delta : -delta\n\n    // Update drag velocity based on the projected movement\n    dragVelocity.current = projectedDelta * dragSensitivity\n\n    // Update last position\n    lastPointerPosition.current = currentPosition\n  }\n\n  const handlePointerUp = (e: React.PointerEvent) => {\n    if (!draggable) return\n    ;(e.currentTarget as HTMLElement).releasePointerCapture(e.pointerId)\n    isDragging.current = false\n\n    if (grabCursor) {\n      ;(e.currentTarget as HTMLElement).style.cursor = \"grab\"\n    }\n  }\n\n  return (\n    <div\n      ref={container}\n      onPointerDown={handlePointerDown}\n      onPointerMove={handlePointerMove}\n      onPointerUp={handlePointerUp}\n      onPointerCancel={handlePointerUp}\n      className={cn(\"relative\", className)}\n    >\n      <svg\n        xmlns=\"http://www.w3.org/2000/svg\"\n        width={width}\n        height={height}\n        viewBox={viewBox}\n        preserveAspectRatio={preserveAspectRatio}\n        className=\"w-full h-full\"\n      >\n        <path\n          id={id}\n          d={path}\n          stroke={showPath ? \"currentColor\" : \"none\"}\n          fill=\"none\"\n          ref={pathRef}\n        />\n      </svg>\n\n      {items.map(({ child, repeatIndex, itemIndex, key }) => {\n        // Create a unique offset transform for each item\n        const itemOffset = useTransform(baseOffset, (v) => {\n          const position = (itemIndex * 100) / items.length\n          const wrappedValue = wrap(0, 100, v + position)\n          return `${easing ? easing(wrappedValue / 100) * 100 : wrappedValue}%`\n        })\n\n        // Create a motion value for the current offset distance\n        const currentOffsetDistance = useMotionValue(0)\n\n        // Update z-index when offset distance changes\n        const zIndex = useTransform(currentOffsetDistance, (value) =>\n          calculateZIndex(value)\n        )\n\n        // Update current offset distance value when animation runs\n        useEffect(() => {\n          const unsubscribe = itemOffset.on(\"change\", (value: string) => {\n            // Parse percentage string to get numerical value\n            const match = value.match(/^([\\d.]+)%$/)\n            if (match && match[1]) {\n              currentOffsetDistance.set(parseFloat(match[1]))\n            }\n          })\n          return unsubscribe\n        }, [itemOffset, currentOffsetDistance])\n\n        const cssVariables = Object.fromEntries(\n          (cssVariableInterpolation || []).map(({ property, from, to }) => [\n            property,\n            useTransform(currentOffsetDistance, [0, 100], [from, to]),\n          ])\n        )\n\n        return (\n          <motion.div\n            key={key}\n            ref={(el) => {\n              if (el) itemRefs.current.set(key, el)\n            }}\n            className={cn(\n              \"absolute top-0 left-0\",\n              draggable && grabCursor && \"cursor-grab\"\n            )}\n            style={{\n              offsetPath: `path('${path}')`,\n              offsetDistance: itemOffset,\n              zIndex: enableRollingZIndex ? zIndex : undefined,\n              ...cssVariables,\n            }}\n            aria-hidden={repeatIndex > 0}\n            onMouseEnter={() => (isHovered.current = true)}\n            onMouseLeave={() => (isHovered.current = false)}\n          >\n            {child}\n          </motion.div>\n        )\n      })}\n    </div>\n  )\n}\n\nexport default MarqueeAlongSvgPath\n",
      "type": "registry:ui",
      "target": "components/fancy/blocks/marquee-along-svg-path.tsx"
    }
  ]
}