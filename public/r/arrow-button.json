{
  "files": [
    {
      "path": "src/components/arrow-pointer.tsx",
      "content": "\"use client\";\n\nimport React, { useRef, useEffect, useState, ReactElement } from 'react';\nimport { motion } from 'framer-motion';\n\ninterface ArrowConfig {\n  thickness?: number;\n  color?: string;\n  type?: 'solid' | 'dashed' | 'dotted';\n  gapBetweenDashes?: number;\n  lineCap?: 'square' | 'round';\n  tipLength?: number;\n  preview?: boolean;\n}\n\ninterface ArrowPointsToCtaProps {\n  button: ReactElement;\n  buttonWidth?: 'default' | 'fill';\n  className?: string;\n  style?: React.CSSProperties;\n  arrow?: ArrowConfig;\n}\n\nconst ArrowPointsToCta: React.FC<ArrowPointsToCtaProps> = ({\n  button,\n  buttonWidth = 'default',\n  className = '',\n  style = {},\n  arrow = {}\n}) => {\n  const {\n    thickness = 1,\n    color = 'rgb(153, 153, 153)',\n    type = 'dashed',\n    gapBetweenDashes = 10,\n    lineCap = 'round',\n    tipLength = 10,\n    preview = true\n  } = arrow;\n\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const containerRef = useRef<HTMLDivElement>(null);\n  const buttonRef = useRef<HTMLDivElement>(null);\n  const [mousePosition, setMousePosition] = useState({ x: 0, y: 0 });\n  const [isButtonVisible, setIsButtonVisible] = useState(false);\n  const [buttonPosition, setButtonPosition] = useState({ x: 0, y: 0 });\n  const [buttonDimensions, setButtonDimensions] = useState({ width: 0, height: 0 });\n\n  // Track mouse position\n  useEffect(() => {\n    const handleMouseMove = (e: MouseEvent) => {\n      setMousePosition({ x: e.clientX, y: e.clientY });\n    };\n\n    window.addEventListener('mousemove', handleMouseMove);\n    return () => window.removeEventListener('mousemove', handleMouseMove);\n  }, []);\n\n  // Check if button is in viewport and get its position\n  useEffect(() => {\n    if (!buttonRef.current) return;\n\n    const observer = new IntersectionObserver(\n      ([entry]) => {\n        setIsButtonVisible(entry.isIntersecting);\n      },\n      { threshold: 0.1 }\n    );\n\n    observer.observe(buttonRef.current);\n\n    const updateButtonPosition = () => {\n      if (buttonRef.current) {\n        const rect = buttonRef.current.getBoundingClientRect();\n        setButtonPosition({ x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 });\n        setButtonDimensions({ width: rect.width, height: rect.height });\n      }\n    };\n\n    // Update on scroll and resize\n    window.addEventListener('scroll', updateButtonPosition);\n    window.addEventListener('resize', updateButtonPosition);\n    updateButtonPosition();\n\n    return () => {\n      observer.disconnect();\n      window.removeEventListener('scroll', updateButtonPosition);\n      window.removeEventListener('resize', updateButtonPosition);\n    };\n  }, []);\n\n  // Draw arrow on canvas\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n\n    const ctx = canvas.getContext('2d');\n    if (!ctx) return;\n\n    // Set canvas size to match window\n    canvas.width = window.innerWidth;\n    canvas.height = window.innerHeight;\n\n    // Clear canvas\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n    // Only draw if button is visible\n    if (!isButtonVisible && !preview) return;\n\n    // Calculate distance between mouse and button\n    const dx = buttonPosition.x - mousePosition.x;\n    const dy = buttonPosition.y - mousePosition.y;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n\n    // Only draw if mouse is far enough from button\n    const minDistance = Math.max(buttonDimensions.width, buttonDimensions.height) / 2 + 50;\n    if (distance < minDistance && !preview) return;\n\n    // Calculate opacity based on distance (fade out as cursor gets closer)\n    const maxDistance = 500; // Maximum distance for full opacity\n    const opacity = Math.min(1, (distance - minDistance) / (maxDistance - minDistance));\n    if (opacity <= 0 && !preview) return;\n\n    // Set up line style\n    ctx.lineWidth = thickness;\n    ctx.strokeStyle = color.replace(')', `, ${opacity})`).replace('rgb', 'rgba');\n    ctx.lineCap = lineCap as CanvasLineCap;\n\n    // Set dash pattern if needed\n    if (type === 'dashed') {\n      ctx.setLineDash([10, gapBetweenDashes]);\n    } else if (type === 'dotted') {\n      ctx.setLineDash([2, gapBetweenDashes]);\n    } else {\n      ctx.setLineDash([]);\n    }\n\n    // Calculate control points for curve\n    const midX = (mousePosition.x + buttonPosition.x) / 2;\n    const midY = (mousePosition.y + buttonPosition.y) / 2;\n    const offsetX = (buttonPosition.y - mousePosition.y) * 0.2;\n    const offsetY = (mousePosition.x - buttonPosition.x) * 0.2;\n\n    // Draw curved line\n    ctx.beginPath();\n    ctx.moveTo(mousePosition.x, mousePosition.y);\n    ctx.quadraticCurveTo(midX + offsetX, midY + offsetY, buttonPosition.x, buttonPosition.y);\n    ctx.stroke();\n\n    // Draw arrow tip\n    const angle = Math.atan2(buttonPosition.y - (midY + offsetY), buttonPosition.x - (midX + offsetX));\n    ctx.beginPath();\n    ctx.moveTo(buttonPosition.x, buttonPosition.y);\n    ctx.lineTo(\n      buttonPosition.x - tipLength * Math.cos(angle - Math.PI / 6),\n      buttonPosition.y - tipLength * Math.sin(angle - Math.PI / 6)\n    );\n    ctx.moveTo(buttonPosition.x, buttonPosition.y);\n    ctx.lineTo(\n      buttonPosition.x - tipLength * Math.cos(angle + Math.PI / 6),\n      buttonPosition.y - tipLength * Math.sin(angle + Math.PI / 6)\n    );\n    ctx.stroke();\n\n  }, [mousePosition, buttonPosition, isButtonVisible, buttonDimensions, thickness, color, type, gapBetweenDashes, lineCap, tipLength, preview]);\n\n  return (\n    <div\n      ref={containerRef}\n      className={`arrow-to-cta-container ${className}`}\n      style={{\n        position: 'relative',\n        width: buttonWidth === 'fill' ? '100%' : 'auto',\n        ...style\n      }}\n    >\n      <canvas\n        ref={canvasRef}\n        style={{\n          position: 'fixed',\n          top: 0,\n          left: 0,\n          width: '100%',\n          height: '100%',\n          pointerEvents: 'none',\n          zIndex: 999\n        }}\n      />\n      <div ref={buttonRef}>\n        {button}\n      </div>\n    </div>\n  );\n};\n\nexport default ArrowPointsToCta;"
    }
  ]
}
