{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "text-rotate",
  "type": "registry:ui",
  "dependencies": [
    "motion"
  ],
  "author": "daniel petho <https://www.danielpetho.com>",
  "registryDependencies": [
    "https://uwuui.com/r/utils.json"
  ],
  "files": [
    {
      "path": "fancy/text/text-rotate.tsx",
      "content": "\"use client\"\n\nimport {\n  ElementType,\n  forwardRef,\n  useCallback,\n  useEffect,\n  useImperativeHandle,\n  useMemo,\n  useState,\n} from \"react\"\nimport {\n  AnimatePresence,\n  AnimatePresenceProps,\n  motion,\n  MotionProps,\n  Transition,\n} from \"motion/react\"\n\nimport { cn } from \"@/lib/utils\"\n\n// handy function to split text into characters with support for unicode and emojis\nconst splitIntoCharacters = (text: string): string[] => {\n  if (typeof Intl !== \"undefined\" && \"Segmenter\" in Intl) {\n    const segmenter = new Intl.Segmenter(\"en\", { granularity: \"grapheme\" })\n    return Array.from(segmenter.segment(text), ({ segment }) => segment)\n  }\n  // Fallback for browsers that don't support Intl.Segmenter\n  return Array.from(text)\n}\n\ninterface TextRotateProps {\n  /**\n   * Array of text strings to rotate through.\n   * Required prop with no default value.\n   */\n  texts: string[]\n\n  /**\n   * render as HTML Tag\n   */\n  as?: ElementType\n\n  /**\n   * Time in milliseconds between text rotations.\n   * @default 2000\n   */\n  rotationInterval?: number\n\n  /**\n   * Initial animation state or array of states.\n   * @default { y: \"100%\", opacity: 0 }\n   */\n  initial?: MotionProps[\"initial\"] | MotionProps[\"initial\"][]\n\n  /**\n   * Animation state to animate to or array of states.\n   * @default { y: 0, opacity: 1 }\n   */\n  animate?: MotionProps[\"animate\"] | MotionProps[\"animate\"][]\n\n  /**\n   * Animation state when exiting or array of states.\n   * @default { y: \"-120%\", opacity: 0 }\n   */\n  exit?: MotionProps[\"exit\"] | MotionProps[\"exit\"][]\n\n  /**\n   * AnimatePresence mode\n   * @default \"wait\"\n   */\n  animatePresenceMode?: AnimatePresenceProps[\"mode\"]\n\n  /**\n   * Whether to run initial animation on first render.\n   * @default false\n   */\n  animatePresenceInitial?: boolean\n\n  /**\n   * Duration of stagger delay between elements in seconds.\n   * @default 0\n   */\n  staggerDuration?: number\n\n  /**\n   * Direction to stagger animations from.\n   * @default \"first\"\n   */\n  staggerFrom?: \"first\" | \"last\" | \"center\" | number | \"random\"\n\n  /**\n   * Animation transition configuration.\n   * @default { type: \"spring\", damping: 25, stiffness: 300 }\n   */\n  transition?: Transition\n\n  /**\n   * Whether to loop through texts continuously.\n   * @default true\n   */\n  loop?: boolean\n\n  /**\n   * Whether to auto-rotate texts.\n   * @default true\n   */\n  auto?: boolean\n\n  /**\n   * How to split the text for animation.\n   * @default \"characters\"\n   */\n  splitBy?: \"words\" | \"characters\" | \"lines\" | string\n\n  /**\n   * Callback function triggered when rotating to next text.\n   * @default undefined\n   */\n  onNext?: (index: number) => void\n\n  /**\n   * Class name for the main container element.\n   * @default undefined\n   */\n  mainClassName?: string\n\n  /**\n   * Class name for the split level wrapper elements.\n   * @default undefined\n   */\n  splitLevelClassName?: string\n\n  /**\n   * Class name for individual animated elements.\n   * @default undefined\n   */\n  elementLevelClassName?: string\n}\n\n/**\n * Interface for the ref object exposed by TextRotate component.\n * Provides methods to control text rotation programmatically.\n * This allows external components to trigger text changes\n * without relying on the automatic rotation.\n */\nexport interface TextRotateRef {\n  /**\n   * Advance to next text in sequence.\n   * If at the end, will loop to beginning if loop prop is true.\n   */\n  next: () => void\n\n  /**\n   * Go back to previous text in sequence.\n   * If at the start, will loop to end if loop prop is true.\n   */\n  previous: () => void\n\n  /**\n   * Jump to specific text by index.\n   * Will clamp index between 0 and texts.length - 1.\n   */\n  jumpTo: (index: number) => void\n\n  /**\n   * Reset back to first text.\n   * Equivalent to jumpTo(0).\n   */\n  reset: () => void\n}\n\n/**\n * Internal interface for representing words when splitting text by characters.\n * Used to maintain proper word spacing and line breaks while allowing\n * character-by-character animation. This prevents words from breaking\n * across lines during animation.\n */\ninterface WordObject {\n  /**\n   * Array of individual characters in the word.\n   * Uses Intl.Segmenter when available for proper Unicode handling.\n   */\n  characters: string[]\n\n  /**\n   * Whether this word needs a space after it.\n   * True for all words except the last one in a sequence.\n   */\n  needsSpace: boolean\n}\n\nconst TextRotate = forwardRef<TextRotateRef, TextRotateProps>(\n  (\n    {\n      texts,\n      as = \"p\",\n      transition = { type: \"spring\", damping: 25, stiffness: 300 },\n      initial = { y: \"100%\", opacity: 0 },\n      animate = { y: 0, opacity: 1 },\n      exit = { y: \"-120%\", opacity: 0 },\n      animatePresenceMode = \"wait\",\n      animatePresenceInitial = false,\n      rotationInterval = 2000,\n      staggerDuration = 0,\n      staggerFrom = \"first\",\n      loop = true,\n      auto = true,\n      splitBy = \"characters\",\n      onNext,\n      mainClassName,\n      splitLevelClassName,\n      elementLevelClassName,\n      ...props\n    },\n    ref\n  ) => {\n    const [currentTextIndex, setCurrentTextIndex] = useState(0)\n\n    // Splitting the text into animation segments\n    const elements = useMemo(() => {\n      const currentText = texts[currentTextIndex]\n      if (splitBy === \"characters\") {\n        const text = currentText.split(\" \")\n        return text.map((word, i) => ({\n          characters: splitIntoCharacters(word),\n          needsSpace: i !== text.length - 1,\n        }))\n      }\n      return splitBy === \"words\"\n        ? currentText.split(\" \")\n        : splitBy === \"lines\"\n          ? currentText.split(\"\\n\")\n          : currentText.split(splitBy)\n    }, [texts, currentTextIndex, splitBy])\n\n    // Helper function to calculate stagger delay for each text segment\n    const getStaggerDelay = useCallback(\n      (index: number, totalChars: number) => {\n        const total = totalChars\n        if (staggerFrom === \"first\") return index * staggerDuration\n        if (staggerFrom === \"last\") return (total - 1 - index) * staggerDuration\n        if (staggerFrom === \"center\") {\n          const center = Math.floor(total / 2)\n          return Math.abs(center - index) * staggerDuration\n        }\n        if (staggerFrom === \"random\") {\n          const randomIndex = Math.floor(Math.random() * total)\n          return Math.abs(randomIndex - index) * staggerDuration\n        }\n        return Math.abs(staggerFrom - index) * staggerDuration\n      },\n      [staggerFrom, staggerDuration]\n    )\n\n    // Helper function to handle index changes and trigger callback\n    const handleIndexChange = useCallback(\n      (newIndex: number) => {\n        setCurrentTextIndex(newIndex)\n        onNext?.(newIndex)\n      },\n      [onNext]\n    )\n\n    // Go to next text\n    const next = useCallback(() => {\n      const nextIndex =\n        currentTextIndex === texts.length - 1\n          ? loop\n            ? 0\n            : currentTextIndex\n          : currentTextIndex + 1\n\n      if (nextIndex !== currentTextIndex) {\n        handleIndexChange(nextIndex)\n      }\n    }, [currentTextIndex, texts.length, loop, handleIndexChange])\n\n    // Go back to previous text\n    const previous = useCallback(() => {\n      const prevIndex =\n        currentTextIndex === 0\n          ? loop\n            ? texts.length - 1\n            : currentTextIndex\n          : currentTextIndex - 1\n\n      if (prevIndex !== currentTextIndex) {\n        handleIndexChange(prevIndex)\n      }\n    }, [currentTextIndex, texts.length, loop, handleIndexChange])\n\n    // Jump to specific text by index\n    const jumpTo = useCallback(\n      (index: number) => {\n        const validIndex = Math.max(0, Math.min(index, texts.length - 1))\n        if (validIndex !== currentTextIndex) {\n          handleIndexChange(validIndex)\n        }\n      },\n      [texts.length, currentTextIndex, handleIndexChange]\n    )\n\n    // Reset back to first text\n    const reset = useCallback(() => {\n      if (currentTextIndex !== 0) {\n        handleIndexChange(0)\n      }\n    }, [currentTextIndex, handleIndexChange])\n\n    // Get animation props for each text segment. If array is provided, states will be mapped to text segments cyclically.\n    const getAnimationProps = useCallback(\n      (index: number) => {\n        const getProp = (\n          prop:\n            | MotionProps[\"initial\"]\n            | MotionProps[\"initial\"][]\n            | MotionProps[\"animate\"]\n            | MotionProps[\"animate\"][]\n            | MotionProps[\"exit\"]\n            | MotionProps[\"exit\"][]\n        ) => {\n          if (Array.isArray(prop)) {\n            return prop[index % prop.length]\n          }\n          return prop\n        }\n\n        return {\n          initial: getProp(initial) as MotionProps[\"initial\"],\n          animate: getProp(animate) as MotionProps[\"animate\"],\n          exit: getProp(exit) as MotionProps[\"exit\"],\n        }\n      },\n      [initial, animate, exit]\n    )\n\n    // Expose all navigation functions via ref\n    useImperativeHandle(\n      ref,\n      () => ({\n        next,\n        previous,\n        jumpTo,\n        reset,\n      }),\n      [next, previous, jumpTo, reset]\n    )\n\n    // Auto-rotate text\n    useEffect(() => {\n      if (!auto) return\n      const intervalId = setInterval(next, rotationInterval)\n      return () => clearInterval(intervalId)\n    }, [next, rotationInterval, auto])\n\n    // Custom motion component to render the text as a custom HTML tag provided via prop\n    const MotionComponent = useMemo(() => motion.create(as ?? \"p\"), [as])\n\n    return (\n      <MotionComponent\n        className={cn(\"flex flex-wrap whitespace-pre-wrap\", mainClassName)}\n        transition={transition}\n        layout\n        {...props}\n      >\n        <span className=\"sr-only\">{texts[currentTextIndex]}</span>\n\n        <AnimatePresence\n          mode={animatePresenceMode}\n          initial={animatePresenceInitial}\n        >\n          <motion.span\n            key={currentTextIndex}\n            className={cn(\n              \"flex flex-wrap\",\n              splitBy === \"lines\" && \"flex-col w-full\"\n            )}\n            aria-hidden\n            layout\n          >\n            {(splitBy === \"characters\"\n              ? (elements as WordObject[])\n              : (elements as string[]).map((el, i) => ({\n                  characters: [el],\n                  needsSpace: i !== elements.length - 1,\n                }))\n            ).map((wordObj, wordIndex, array) => {\n              const previousCharsCount = array\n                .slice(0, wordIndex)\n                .reduce((sum, word) => sum + word.characters.length, 0)\n\n              return (\n                <span\n                  key={wordIndex}\n                  className={cn(\"inline-flex\", splitLevelClassName)}\n                >\n                  {wordObj.characters.map((char, charIndex) => {\n                    const totalIndex = previousCharsCount + charIndex\n                    const animationProps = getAnimationProps(totalIndex)\n                    return (\n                      <span \n                      key={totalIndex}\n                      className={cn(elementLevelClassName)}\n                      >\n                        <motion.span\n                          {...animationProps}\n                          key={charIndex}\n                          transition={{\n                            ...transition,\n                            delay: getStaggerDelay(\n                              previousCharsCount + charIndex,\n                              array.reduce(\n                                (sum, word) => sum + word.characters.length,\n                                0\n                              )\n                            ),\n                          }}\n                          className={\"inline-block\"}\n                        >\n                          {char}\n                        </motion.span>\n                      </span>\n                    )\n                  })}\n                  {wordObj.needsSpace && (\n                    <span className=\"whitespace-pre\"> </span>\n                  )}\n                </span>\n              )\n            })}\n          </motion.span>\n        </AnimatePresence>\n      </MotionComponent>\n    )\n  }\n)\n\nTextRotate.displayName = \"TextRotate\"\n\nexport default TextRotate",
      "type": "registry:ui",
      "target": "components/fancy/text/text-rotate.tsx"
    }
  ]
}