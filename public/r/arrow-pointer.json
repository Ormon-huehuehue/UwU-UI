{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "arrow-pointer",
  "type": "registry:ui",
  "dependencies": [
    "framer-motion"
  ],
  "author": "daniel petho <https://www.danielpetho.com>",
  "files": [
    {
      "path": "components/arrow-pointer.tsx",
      "content": "'use client'\n\nimport React, { useEffect, useRef, useState, ReactElement, cloneElement } from 'react'\nimport { useInView } from 'framer-motion'\n\n// Types and Enums\nenum ArrowType {\n  SOLID = \"solid\",\n  DASHED = \"dashed\", \n  DOTTED = \"dotted\"\n}\n\nenum ArrowLineCap {\n  SQUARE = \"square\",\n  ROUND = \"round\"\n}\n\ninterface ArrowConfig {\n  thickness: number\n  color: string\n  type: ArrowType\n  gapBetweenDashes: number\n  lineCap: ArrowLineCap\n  tipLength: number\n  preview: boolean\n}\n\ninterface ArrowPointsToCtaProps {\n  button?: ReactElement\n  buttonWidth?: \"default\" | \"fill\"\n  arrow: ArrowConfig\n  className?: string\n  style?: React.CSSProperties\n}\n\n// Global mouse position tracking\nif (typeof window !== \"undefined\") {\n  window.addEventListener(\"mousemove\", (e: MouseEvent) => {\n    ;(window as any).mouseX = e.clientX\n    ;(window as any).mouseY = e.clientY\n  })\n}\n\n// Component Message for when no button is connected\nconst ComponentMessage: React.FC<{\n  title: string\n  subtitle: string\n  style?: React.CSSProperties\n}> = ({ title, subtitle, style }) => {\n  return (\n    <div\n      style={{\n        width: \"100%\",\n        height: \"100%\",\n        display: \"flex\",\n        flexDirection: \"column\",\n        justifyContent: \"center\",\n        alignItems: \"center\",\n        padding: \"20px\",\n        textAlign: \"center\",\n        border: \"2px dashed #ccc\",\n        borderRadius: \"8px\",\n        backgroundColor: \"#f9f9f9\",\n        ...style\n      }}\n    >\n      <h3 style={{ margin: \"0 0 10px 0\", fontSize: \"18px\", fontWeight: \"600\" }}>\n        {title}\n      </h3>\n      <p style={{ margin: 0, fontSize: \"14px\", color: \"#666\", lineHeight: \"1.4\" }}>\n        {subtitle}\n      </p>\n    </div>\n  )\n}\n\n// Default props\nconst defaultProps: ArrowPointsToCtaProps = {\n  button: undefined,\n  buttonWidth: \"default\",\n  arrow: {\n    thickness: 1,\n    color: \"rgb(153, 153, 153)\",\n    type: ArrowType.DASHED,\n    gapBetweenDashes: 10,\n    lineCap: ArrowLineCap.ROUND,\n    tipLength: 10,\n    preview: true\n  }\n}\n\n// Helper functions\nconst parseFramerColor = (color: string) => {\n  const rgbMatch = color.match(/rgb\\((\\d+),\\s*(\\d+),\\s*(\\d+)\\)/)\n  const rgbaMatch = color.match(/rgba\\((\\d+),\\s*(\\d+),\\s*(\\d+),\\s*([\\d.]+)\\)/)\n\n  if (rgbaMatch) {\n    const [_, r, g, b, a] = rgbaMatch\n    return {\n      rgbString: `rgba(${r}, ${g}, ${b}, ${a})`,\n      rgbObject: { r: parseInt(r), g: parseInt(g), b: parseInt(b), a: parseFloat(a) }\n    }\n  } else if (rgbMatch) {\n    const [_, r, g, b] = rgbMatch\n    return {\n      rgbString: `rgba(${r}, ${g}, ${b}, 1)`,\n      rgbObject: { r: parseInt(r), g: parseInt(g), b: parseInt(b), a: 1 }\n    }\n  }\n\n  console.warn(\"Could not parse color:\", color)\n  return {\n    rgbString: \"rgba(0, 0, 0, 1)\",\n    rgbObject: { r: 0, g: 0, b: 0, a: 1 }\n  }\n}\n\nconst useBreakpoint = () => {\n  const [breakpoint, setBreakpoint] = useState<\"mobile\" | \"tablet\" | \"desktop\" | null>(null)\n\n  useEffect(() => {\n    const checkBreakpoint = () => {\n      if (window.innerWidth <= 809) {\n        setBreakpoint(\"mobile\")\n      } else if (window.innerWidth <= 1199) {\n        setBreakpoint(\"tablet\")\n      } else {\n        setBreakpoint(\"desktop\")\n      }\n    }\n\n    checkBreakpoint()\n    window.addEventListener(\"resize\", checkBreakpoint)\n    return () => window.removeEventListener(\"resize\", checkBreakpoint)\n  }, [])\n\n  return breakpoint\n}\n\nconst updateCanvas = ({ canvasRef, targetRef }: {\n  canvasRef: React.RefObject<HTMLCanvasElement>\n  targetRef: React.RefObject<HTMLDivElement>\n}) => {\n  if (!canvasRef || !targetRef || typeof window === \"undefined\") return\n\n  const canvas = canvasRef.current\n  const target = targetRef.current\n  if (!canvas || !target) return\n\n  const targetDimensions = target.getBoundingClientRect()\n  canvas.width = window.innerWidth\n  canvas.height = window.innerHeight * 2 + targetDimensions.height\n}\n\nconst drawPreviewArrow = ({ ctx, canvas, framerProps, rgbColor }: {\n  ctx: CanvasRenderingContext2D\n  canvas: HTMLCanvasElement\n  framerProps: ArrowPointsToCtaProps\n  rgbColor: ReturnType<typeof parseFramerColor>\n}) => {\n  if (!ctx || !canvas) return\n\n  ctx.clearRect(0, 0, canvas.width, canvas.height)\n\n  const centerX = canvas.width / 2\n  const centerY = canvas.height / 2 - 50\n  const startX = centerX\n  const startY = centerY - 200\n\n  ctx.strokeStyle = rgbColor.rgbString\n  ctx.lineWidth = framerProps.arrow.thickness\n\n  const lineDash = framerProps.arrow.type === \"dashed\" \n    ? [10 + framerProps.arrow.thickness, framerProps.arrow.gapBetweenDashes]\n    : framerProps.arrow.type === \"dotted\"\n    ? [framerProps.arrow.thickness, framerProps.arrow.gapBetweenDashes]\n    : framerProps.arrow.type === \"solid\"\n    ? []\n    : [10, framerProps.arrow.gapBetweenDashes]\n\n  ctx.beginPath()\n  ctx.setLineDash(lineDash)\n  ctx.moveTo(startX, startY)\n  ctx.lineTo(centerX, centerY)\n  ctx.stroke()\n\n  const headLength = framerProps.arrow.tipLength\n  const angle = Math.PI / 2\n\n  ctx.lineCap = framerProps.arrow.lineCap\n  ctx.beginPath()\n  ctx.setLineDash([])\n  ctx.moveTo(centerX, centerY)\n  ctx.lineTo(\n    centerX - headLength * Math.cos(angle - Math.PI / 6),\n    centerY - headLength * Math.sin(angle - Math.PI / 6)\n  )\n  ctx.moveTo(centerX, centerY)\n  ctx.lineTo(\n    centerX - headLength * Math.cos(angle + Math.PI / 6),\n    centerY - headLength * Math.sin(angle + Math.PI / 6)\n  )\n  ctx.stroke()\n}\n\nconst drawArrow = ({ ctx, target, canvas, mouseRef, currentOpacity, framerProps, rgbColor }: {\n  ctx: CanvasRenderingContext2D\n  target: HTMLDivElement\n  canvas: HTMLCanvasElement\n  mouseRef: React.MutableRefObject<{ x: number | null; y: number | null }>\n  currentOpacity: number\n  framerProps: ArrowPointsToCtaProps\n  rgbColor: ReturnType<typeof parseFramerColor>\n}) => {\n  if (!ctx || !target || !canvas) return\n\n  const { x: mouseX, y: mouseY } = mouseRef.current\n  if (!mouseX || !mouseY) return\n\n  const targetRect = target.getBoundingClientRect()\n\n  if (mouseX >= targetRect.left && mouseX <= targetRect.right && \n      mouseY >= targetRect.top && mouseY <= targetRect.bottom) {\n    return\n  }\n\n  const canvasRect = canvas.getBoundingClientRect()\n  const x0 = mouseX - canvasRect.left\n  const y0 = mouseY - canvasRect.top\n  const cx = targetRect.left - canvasRect.left + targetRect.width / 2\n  const cy = targetRect.top - canvasRect.top + targetRect.height / 2\n\n  const a = Math.atan2(cy - y0, cx - x0)\n  const x1 = cx - Math.cos(a) * (targetRect.width / 2 + 20)\n  const y1 = cy - Math.sin(a) * (targetRect.height / 2 + 20)\n\n  const midX = (x0 + x1) / 2\n  const midY = (y0 + y1) / 2\n  const offset = Math.min(200, Math.hypot(x1 - x0, y1 - y0) * 0.5)\n  const t = Math.max(-1, Math.min(1, (y0 - y1) / 200))\n  const controlX = midX\n  const controlY = midY + offset * t\n\n  const verticalDistance = mouseY < targetRect.top ? targetRect.top - mouseY :\n    mouseY > targetRect.bottom ? mouseY - targetRect.bottom : 0\n  const horizontalDistance = mouseX < targetRect.left ? targetRect.left - mouseX :\n    mouseX > targetRect.right ? mouseX - targetRect.right : 0\n\n  const distance = Math.max(verticalDistance, horizontalDistance)\n  const minDistance = 100\n  const maxDistance = 200\n  const distanceOpacity = Math.min(0.75, Math.max(0, (distance - minDistance) / (maxDistance - minDistance)))\n  const opacity = distanceOpacity * currentOpacity\n\n  ctx.strokeStyle = `rgba(${rgbColor.rgbObject.r},${rgbColor.rgbObject.g},${rgbColor.rgbObject.b},${opacity})`\n  ctx.lineWidth = framerProps.arrow.thickness\n\n  const lineDash = framerProps.arrow.type === \"dashed\"\n    ? [10 + framerProps.arrow.thickness, framerProps.arrow.gapBetweenDashes]\n    : framerProps.arrow.type === \"dotted\"\n    ? [framerProps.arrow.thickness, framerProps.arrow.gapBetweenDashes]\n    : framerProps.arrow.type === \"solid\"\n    ? []\n    : [10, framerProps.arrow.gapBetweenDashes]\n\n  ctx.lineCap = framerProps.arrow.lineCap\n  ctx.save()\n  ctx.beginPath()\n  ctx.moveTo(x0, y0)\n\n  const angle = Math.atan2(y1 - controlY, x1 - controlX)\n  const headLength = framerProps.arrow.tipLength\n  const gapSize = headLength * -0.3\n  const lineEndX = x1 + gapSize * Math.cos(angle)\n  const lineEndY = y1 + gapSize * Math.sin(angle)\n\n  ctx.quadraticCurveTo(controlX, controlY, lineEndX, lineEndY)\n  ctx.setLineDash(lineDash)\n  ctx.stroke()\n  ctx.restore()\n\n  ctx.beginPath()\n  ctx.moveTo(x1, y1)\n  ctx.lineTo(\n    x1 - headLength * Math.cos(angle - Math.PI / 6),\n    y1 - headLength * Math.sin(angle - Math.PI / 6)\n  )\n  ctx.moveTo(x1, y1)\n  ctx.lineTo(\n    x1 - headLength * Math.cos(angle + Math.PI / 6),\n    y1 - headLength * Math.sin(angle + Math.PI / 6)\n  )\n  ctx.stroke()\n}\n\nconst animate = ({ ctx, target, wrapperRef, canvas, mouseRef, animationFrameRef, targetInView, opacityRef, framerProps, rgbColor }: {\n  ctx: CanvasRenderingContext2D\n  target: HTMLDivElement\n  wrapperRef: React.RefObject<HTMLDivElement>\n  canvas: HTMLCanvasElement\n  mouseRef: React.MutableRefObject<{ x: number | null; y: number | null }>\n  animationFrameRef: React.MutableRefObject<number | null>\n  targetInView: boolean\n  opacityRef: React.MutableRefObject<number>\n  framerProps: ArrowPointsToCtaProps\n  rgbColor: ReturnType<typeof parseFramerColor>\n}) => {\n  if (!ctx || !canvas) return\n\n  const targetOpacity = targetInView ? 1 : 0\n  const opacityDiff = targetOpacity - opacityRef.current\n  const duration = 100\n  const step = 16\n\n  if (Math.abs(opacityDiff) > 0.001) {\n    const stepPercentage = step / duration\n    const newOpacity = opacityRef.current + opacityDiff * stepPercentage\n\n    if (targetInView) {\n      opacityRef.current = Math.min(1, newOpacity)\n    } else {\n      opacityRef.current = Math.max(0, newOpacity)\n    }\n  }\n\n  ctx.clearRect(0, 0, canvas.width, canvas.height)\n\n  if (opacityRef.current > 0) {\n    drawArrow({ ctx, target, canvas, mouseRef, currentOpacity: opacityRef.current, framerProps, rgbColor })\n  }\n\n  if (Math.abs(opacityDiff) > 0.001 || (targetInView && opacityRef.current > 0)) {\n    animationFrameRef.current = requestAnimationFrame(() =>\n      animate({ ctx, target, wrapperRef, canvas, mouseRef, animationFrameRef, targetInView, opacityRef, framerProps, rgbColor })\n    )\n  }\n}\n\nconst useMouseEvents = ({ isOnFramerCanvas, canvasRef, targetRef, wrapperRef, mouseRef, animationFrameRef, targetInView, framerProps, rgbColor }: {\n  isOnFramerCanvas: boolean\n  canvasRef: React.RefObject<HTMLCanvasElement>\n  targetRef: React.RefObject<HTMLDivElement>\n  wrapperRef: React.RefObject<HTMLDivElement>\n  mouseRef: React.MutableRefObject<{ x: number | null; y: number | null }>\n  animationFrameRef: React.MutableRefObject<number | null>\n  targetInView: boolean\n  framerProps: ArrowPointsToCtaProps\n  rgbColor: ReturnType<typeof parseFramerColor>\n}) => {\n  const opacityRef = useRef(0)\n  const lastTargetInView = useRef(targetInView)\n  const breakpoint = useBreakpoint()\n\n  useEffect(() => {\n    if (isOnFramerCanvas || breakpoint === \"mobile\") return\n\n    const canvas = canvasRef.current\n    const target = targetRef.current\n    if (!canvas || !target) return\n\n    const ctx = canvas.getContext(\"2d\")\n    if (!ctx) return\n\n    const updateMousePosition = (e: MouseEvent) => {\n      mouseRef.current = { x: e.clientX, y: e.clientY }\n    }\n\n    let handleMouseMove: ((e: MouseEvent) => void) | null = null\n    if (targetInView) {\n      handleMouseMove = updateMousePosition\n      window.addEventListener(\"mousemove\", handleMouseMove)\n\n      if (!lastTargetInView.current) {\n        updateMousePosition({\n          clientX: (window as any).mouseX || 0,\n          clientY: (window as any).mouseY || 0\n        } as MouseEvent)\n      }\n    }\n\n    lastTargetInView.current = targetInView\n\n    animate({ ctx, target, wrapperRef, canvas, mouseRef, animationFrameRef, targetInView, opacityRef, framerProps, rgbColor })\n\n    return () => {\n      if (handleMouseMove) {\n        window.removeEventListener(\"mousemove\", handleMouseMove)\n      }\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current)\n      }\n    }\n  }, [isOnFramerCanvas, targetInView, breakpoint])\n}\n\n// Main component\nexport const ArrowPointsToCta: React.FC<ArrowPointsToCtaProps> = (props) => {\n  const mergedProps = { ...defaultProps, ...props }\n  const isOnFramerCanvas = false // In Next.js, this is always false\n  const haveNativeButton = mergedProps.button !== undefined\n\n  const canvasRef = useRef<HTMLCanvasElement>(null)\n  const targetRef = useRef<HTMLDivElement>(null)\n  const wrapperRef = useRef<HTMLDivElement>(null)\n  const mouseRef = useRef<{ x: number | null; y: number | null }>({ x: null, y: null })\n  const animationFrameRef = useRef<number | null>(null)\n\n  const rgbColor = parseFramerColor(mergedProps.arrow.color)\n  const targetInView = useInView(targetRef)\n\n  useEffect(() => {\n    updateCanvas({ canvasRef, targetRef })\n\n    const debounce = (fn: Function, delay: number) => {\n      let timeoutId: NodeJS.Timeout\n      return (...args: any[]) => {\n        clearTimeout(timeoutId)\n        timeoutId = setTimeout(() => fn(...args), delay)\n      }\n    }\n\n    const debouncedResize = debounce(() => {\n      updateCanvas({ canvasRef, targetRef })\n    }, 150)\n\n    window.addEventListener(\"resize\", debouncedResize)\n    return () => window.removeEventListener(\"resize\", debouncedResize)\n  }, [haveNativeButton])\n\n  useEffect(() => {\n    if (isOnFramerCanvas && mergedProps.arrow.preview) {\n      const canvas = canvasRef.current\n      if (!canvas) return\n\n      const ctx = canvas.getContext(\"2d\")\n      if (!ctx) return\n\n      drawPreviewArrow({ ctx, canvas, framerProps: mergedProps, rgbColor })\n    }\n\n    return () => {\n      const canvas = canvasRef.current\n      if (!canvas) return\n\n      const ctx = canvas.getContext(\"2d\")\n      if (!ctx) return\n\n      ctx.clearRect(0, 0, canvas.width, canvas.height)\n    }\n  }, [isOnFramerCanvas, mergedProps, rgbColor])\n\n  useMouseEvents({\n    isOnFramerCanvas,\n    canvasRef,\n    targetRef,\n    wrapperRef,\n    mouseRef,\n    animationFrameRef,\n    targetInView,\n    framerProps: mergedProps,\n    rgbColor\n  })\n\n  if (!haveNativeButton) {\n    return (\n      <div style={{ width: \"100%\", height: \"100%\", ...mergedProps.style }} className={mergedProps.className}>\n        <ComponentMessage\n          title=\"Arrow Points to CTA\"\n          subtitle=\"Set up the component by connecting button to the component or selecting the button from the component properties.\"\n        />\n      </div>\n    )\n  }\n\n  return (\n    <div\n      ref={wrapperRef}\n      style={{\n        width: \"100%\",\n        height: \"100%\",\n        display: \"flex\",\n        justifyContent: \"center\",\n        alignItems: \"center\",\n        position: \"relative\",\n        ...mergedProps.style\n      }}\n      className={mergedProps.className}\n    >\n      <div\n        ref={targetRef}\n        style={{\n          overflow: \"visible\",\n          width: mergedProps.buttonWidth === \"default\" ? \"fit-content\" : \"100%\",\n          display: \"flex\"\n        }}\n      >\n        {React.Children.map(mergedProps.button, (child) => {\n          if (React.isValidElement(child)) {\n            return cloneElement(child, {\n              style: {\n                // @ts-ignore \n                // @eslint-disable-next-line\n                ...child.props.style as React.CSSProperties,\n                // @eslint-disable-next-line\n                // @ts-ignore\n                width: mergedProps.buttonWidth === \"fill\" ? \"100%\" : child.props.style?.width\n              }\n            } as any)\n          }\n          return child\n        })}\n      </div>\n      <canvas\n        ref={canvasRef}\n        style={{\n          position: \"absolute\",\n          top: \"50%\",\n          left: \"50%\",\n          transform: \"translate(-50%, -50%)\",\n          pointerEvents: \"none\",\n          zIndex: 2147483647\n        }}\n      />\n    </div>\n  )\n}\n\nArrowPointsToCta.displayName = \"Arrow Points to CTA\"\n\nexport default ArrowPointsToCta",
      "type": "registry:ui",
      "target": "components/fancy/components/arrow-pointer.tsx"
    }
  ]
}