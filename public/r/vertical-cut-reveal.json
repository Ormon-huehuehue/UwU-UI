{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "vertical-cut-reveal",
  "type": "registry:ui",
  "dependencies": [
    "motion"
  ],
  "author": "daniel petho <https://www.danielpetho.com>",
  "registryDependencies": [
    "https://uwuui.com/r/utils.json"
  ],
  "files": [
    {
      "path": "fancy/text/vertical-cut-reveal.tsx",
      "content": "\"use client\"\n\nimport { AnimationOptions, motion } from \"motion/react\"\nimport {\n  forwardRef,\n  useCallback,\n  useEffect,\n  useImperativeHandle,\n  useMemo,\n  useRef,\n  useState,\n} from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\ninterface TextProps {\n  children: React.ReactNode\n  reverse?: boolean\n  transition?: AnimationOptions\n  splitBy?: \"words\" | \"characters\" | \"lines\" | string\n  staggerDuration?: number\n  staggerFrom?: \"first\" | \"last\" | \"center\" | \"random\" | number\n  containerClassName?: string\n  wordLevelClassName?: string\n  elementLevelClassName?: string\n  onClick?: () => void\n  onStart?: () => void\n  onComplete?: () => void\n  autoStart?: boolean // Whether to start the animation automatically\n}\n\n// Ref interface to allow external control of the animation\nexport interface VerticalCutRevealRef {\n  startAnimation: () => void\n  reset: () => void\n}\n\ninterface WordObject {\n  characters: string[]\n  needsSpace: boolean\n}\n\nconst VerticalCutReveal = forwardRef<VerticalCutRevealRef, TextProps>(\n  (\n    {\n      children,\n      reverse = false,\n      transition = {\n        type: \"spring\",\n        stiffness: 190,\n        damping: 22,\n      },\n      splitBy = \"words\",\n      staggerDuration = 0.2,\n      staggerFrom = \"first\",\n      containerClassName,\n      wordLevelClassName,\n      elementLevelClassName,\n      onClick,\n      onStart,\n      onComplete,\n      autoStart = true,\n      ...props\n    },\n    ref\n  ) => {\n    const containerRef = useRef<HTMLSpanElement>(null)\n    const text =\n      typeof children === \"string\" ? children : children?.toString() || \"\"\n    const [isAnimating, setIsAnimating] = useState(false)\n\n    // handy function to split text into characters with support for unicode and emojis\n    const splitIntoCharacters = (text: string): string[] => {\n      if (typeof Intl !== \"undefined\" && \"Segmenter\" in Intl) {\n        const segmenter = new Intl.Segmenter(\"en\", { granularity: \"grapheme\" })\n        return Array.from(segmenter.segment(text), ({ segment }) => segment)\n      }\n      // Fallback for browsers that don't support Intl.Segmenter\n      return Array.from(text)\n    }\n\n    // Split text based on splitBy parameter\n    const elements = useMemo(() => {\n      const words = text.split(\" \")\n      if (splitBy === \"characters\") {\n        return words.map((word, i) => ({\n          characters: splitIntoCharacters(word),\n          needsSpace: i !== words.length - 1,\n        }))\n      }\n      return splitBy === \"words\"\n        ? text.split(\" \")\n        : splitBy === \"lines\"\n          ? text.split(\"\\n\")\n          : text.split(splitBy)\n    }, [text, splitBy])\n\n    // Calculate stagger delays based on staggerFrom\n    const getStaggerDelay = useCallback(\n      (index: number) => {\n        const total =\n          splitBy === \"characters\"\n            ? elements.reduce(\n                (acc, word) =>\n                  acc +\n                  (typeof word === \"string\"\n                    ? 1\n                    : word.characters.length + (word.needsSpace ? 1 : 0)),\n                0\n              )\n            : elements.length\n        if (staggerFrom === \"first\") return index * staggerDuration\n        if (staggerFrom === \"last\") return (total - 1 - index) * staggerDuration\n        if (staggerFrom === \"center\") {\n          const center = Math.floor(total / 2)\n          return Math.abs(center - index) * staggerDuration\n        }\n        if (staggerFrom === \"random\") {\n          const randomIndex = Math.floor(Math.random() * total)\n          return Math.abs(randomIndex - index) * staggerDuration\n        }\n        return Math.abs(staggerFrom - index) * staggerDuration\n      },\n      [elements.length, staggerFrom, staggerDuration]\n    )\n\n    const startAnimation = useCallback(() => {\n      setIsAnimating(true)\n      onStart?.()\n    }, [onStart])\n\n    // Expose the startAnimation function via ref\n    useImperativeHandle(ref, () => ({\n      startAnimation,\n      reset: () => setIsAnimating(false),\n    }))\n\n    // Auto start animation\n    useEffect(() => {\n      if (autoStart) {\n        startAnimation()\n      }\n    }, [autoStart])\n\n    const variants = {\n      hidden: { y: reverse ? \"-100%\" : \"100%\" },\n      visible: (i: number) => ({\n        y: 0,\n        transition: {\n          ...transition,\n          delay: ((transition?.delay as number) || 0) + getStaggerDelay(i),\n        },\n      }),\n    }\n\n    return (\n      <span\n        className={cn(\n          containerClassName,\n          \"flex flex-wrap whitespace-pre-wrap\",\n          splitBy === \"lines\" && \"flex-col\"\n        )}\n        onClick={onClick}\n        ref={containerRef}\n        {...props}\n      >\n        <span className=\"sr-only\">{text}</span>\n\n        {(splitBy === \"characters\"\n          ? (elements as WordObject[])\n          : (elements as string[]).map((el, i) => ({\n              characters: [el],\n              needsSpace: i !== elements.length - 1,\n            }))\n        ).map((wordObj, wordIndex, array) => {\n          const previousCharsCount = array\n            .slice(0, wordIndex)\n            .reduce((sum, word) => sum + word.characters.length, 0)\n\n          return (\n            <span\n              key={wordIndex}\n              aria-hidden=\"true\"\n              className={cn(\"inline-flex overflow-hidden\", wordLevelClassName)}\n            >\n              {wordObj.characters.map((char, charIndex) => (\n                <span\n                  className={cn(\n                    elementLevelClassName,\n                    \"whitespace-pre-wrap relative\"\n                  )}\n                  key={charIndex}\n                >\n                  <motion.span\n                    custom={previousCharsCount + charIndex}\n                    initial=\"hidden\"\n                    animate={isAnimating ? \"visible\" : \"hidden\"}\n                    variants={variants}\n                    onAnimationComplete={\n                      wordIndex === elements.length - 1 &&\n                      charIndex === wordObj.characters.length - 1\n                        ? onComplete\n                        : undefined\n                    }\n                    className=\"inline-block\"\n                  >\n                    {char}\n                  </motion.span>\n                </span>\n              ))}\n              {wordObj.needsSpace && <span> </span>}\n            </span>\n          )\n        })}\n      </span>\n    )\n  }\n)\n\nVerticalCutReveal.displayName = \"VerticalCutReveal\"\nexport default VerticalCutReveal\n",
      "type": "registry:ui",
      "target": "components/fancy/text/vertical-cut-reveal.tsx"
    }
  ]
}