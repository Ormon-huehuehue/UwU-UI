{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "cursor-attractor-and-gravity",
  "type": "registry:ui",
  "dependencies": [
    "lodash",
    "matter-js",
    "svg-path-commander",
    "poly-decomp",
    "@types/matter-js"
  ],
  "author": "daniel petho <https://www.danielpetho.com>",
  "registryDependencies": [
    "https://uwuui.com/r/calculate-position.json",
    "https://uwuui.com/r/svg-path-to-vertices.json",
    "https://uwuui.com/r/utils.json",
    "https://uwuui.com/r/use-mouse-position-ref.json"
  ],
  "files": [
    {
      "path": "fancy/physics/cursor-attractor-and-gravity.tsx",
      "content": "\"use client\"\n\nimport {\n  createContext,\n  forwardRef,\n  ReactNode,\n  useCallback,\n  useContext,\n  useEffect,\n  useImperativeHandle,\n  useRef,\n  useState,\n} from \"react\"\nimport { calculatePosition } from \"@/utils/calculate-position\"\nimport { parsePathToVertices } from \"@/utils/svg-path-to-vertices\"\nimport { debounce } from \"lodash\"\nimport Matter, {\n  Bodies,\n  Common,\n  Engine,\n  Events,\n  Render,\n  Runner,\n  World,\n  Body,\n} from \"matter-js\"\n\nimport { cn } from \"@/lib/utils\"\nimport { useMousePositionRef } from \"@/hooks/use-mouse-position-ref\"\n\ntype GravityProps = {\n  children: ReactNode\n  debug?: boolean\n  attractorPoint?: { x: number | string; y: number | string }\n  attractorStrength?: number\n  cursorStrength?: number\n  cursorFieldRadius?: number\n  resetOnResize?: boolean\n  addTopWall?: boolean\n  autoStart?: boolean\n  className?: string\n}\n\ntype PhysicsBody = {\n  element: HTMLElement\n  body: Matter.Body\n  props: MatterBodyProps\n}\n\ntype MatterBodyProps = {\n  children: ReactNode\n  matterBodyOptions?: Matter.IBodyDefinition\n  isDraggable?: boolean\n  bodyType?: \"rectangle\" | \"circle\" | \"svg\"\n  sampleLength?: number\n  x?: number | string\n  y?: number | string\n  angle?: number\n  className?: string\n}\n\nexport type GravityRef = {\n  start: () => void\n  stop: () => void\n  reset: () => void\n}\n\nconst GravityContext = createContext<{\n  registerElement: (\n    id: string,\n    element: HTMLElement,\n    props: MatterBodyProps\n  ) => void\n  unregisterElement: (id: string) => void\n} | null>(null)\n\nexport const MatterBody = ({\n  children,\n  className,\n  matterBodyOptions = {\n    friction: 0.1,\n    restitution: 0.1,\n    density: 0.001,\n    isStatic: false,\n  },\n  bodyType = \"rectangle\",\n  isDraggable = true,\n  sampleLength = 15,\n  x = 0,\n  y = 0,\n  angle = 0,\n  ...props\n}: MatterBodyProps) => {\n  const elementRef = useRef<HTMLDivElement>(null)\n  const idRef = useRef(Math.random().toString(36).substring(7))\n  const context = useContext(GravityContext)\n\n  useEffect(() => {\n    if (!elementRef.current || !context) return\n    context.registerElement(idRef.current, elementRef.current, {\n      children,\n      matterBodyOptions,\n      bodyType,\n      sampleLength,\n      isDraggable,\n      x,\n      y,\n      angle,\n      ...props,\n    })\n\n    return () => context.unregisterElement(idRef.current)\n  }, [props, children, matterBodyOptions, isDraggable])\n\n  return (\n    <div\n      ref={elementRef}\n      className={cn(\n        \"absolute\",\n        className,\n      )}\n    >\n      {children}\n    </div>\n  )\n}\n\nconst Gravity = forwardRef<GravityRef, GravityProps>(\n  (\n    {\n      children,\n      debug = false,\n      attractorPoint = { x: 0.5, y: 0.5 },\n      attractorStrength = 0.001,\n      cursorStrength = 0.0005,\n      cursorFieldRadius = 100,\n      resetOnResize = true,\n      addTopWall = true,\n      autoStart = true,\n      className,\n      ...props\n    },\n    ref\n  ) => {\n    const canvas = useRef<HTMLDivElement>(null)\n    const engine = useRef(Engine.create())\n    const render = useRef<Render>()\n    const runner = useRef<Runner>()\n    const bodiesMap = useRef(new Map<string, PhysicsBody>())\n    const frameId = useRef<number>()\n    const [canvasSize, setCanvasSize] = useState({ width: 0, height: 0 })\n    const mouseRef = useMousePositionRef(canvas)\n\n    const isRunning = useRef(false)\n\n    // Register Matter.js body in the physics world\n    const registerElement = useCallback(\n      (id: string, element: HTMLElement, props: MatterBodyProps) => {\n        if (!canvas.current) return\n        const width = element.offsetWidth\n        const height = element.offsetHeight\n        const canvasRect = canvas.current!.getBoundingClientRect()\n\n        const angle = (props.angle || 0) * (Math.PI / 180)\n\n        const x = calculatePosition(props.x, canvasRect.width, width)\n        const y = calculatePosition(props.y, canvasRect.height, height)\n\n        let body\n        if (props.bodyType === \"circle\") {\n          const radius = Math.max(width, height) / 2\n          body = Bodies.circle(x, y, radius, {\n            ...props.matterBodyOptions,\n            angle: angle,\n            render: {\n              fillStyle: debug ? \"#888888\" : \"#00000000\",\n              strokeStyle: debug ? \"#333333\" : \"#00000000\",\n              lineWidth: debug ? 3 : 0,\n            },\n          })\n        } else if (props.bodyType === \"svg\") {\n          const paths = element.querySelectorAll(\"path\")\n          const vertexSets: Matter.Vector[][] = []\n\n          paths.forEach((path) => {\n            const d = path.getAttribute(\"d\")\n            const p = parsePathToVertices(d!, props.sampleLength)\n            vertexSets.push(p)\n          })\n\n          body = Bodies.fromVertices(x, y, vertexSets, {\n            ...props.matterBodyOptions,\n            angle: angle,\n            render: {\n              fillStyle: debug ? \"#888888\" : \"#00000000\",\n              strokeStyle: debug ? \"#333333\" : \"#00000000\",\n              lineWidth: debug ? 3 : 0,\n            },\n          })\n        } else {\n          body = Bodies.rectangle(x, y, width, height, {\n            ...props.matterBodyOptions,\n            angle: angle,\n            render: {\n              fillStyle: debug ? \"#888888\" : \"#00000000\",\n              strokeStyle: debug ? \"#333333\" : \"#00000000\",\n              lineWidth: debug ? 3 : 0,\n            },\n          })\n        }\n\n        if (body) {\n          World.add(engine.current.world, [body])\n          bodiesMap.current.set(id, { element, body, props })\n        }\n      },\n      [debug]\n    )\n\n    // Unregister Matter.js body from the physics world\n    const unregisterElement = useCallback((id: string) => {\n      const body = bodiesMap.current.get(id)\n      if (body) {\n        World.remove(engine.current.world, body.body)\n        bodiesMap.current.delete(id)\n      }\n    }, [])\n\n    // Keep react elements in sync with the physics world\n    const updateElements = useCallback(() => {\n      bodiesMap.current.forEach(({ element, body }) => {\n        const { x, y } = body.position\n        const rotation = body.angle * (180 / Math.PI)\n\n        element.style.transform = `translate(${\n          x - element.offsetWidth / 2\n        }px, ${y - element.offsetHeight / 2}px) rotate(${rotation}deg)`\n      })\n\n      frameId.current = requestAnimationFrame(updateElements)\n    }, [])\n\n    const initializeRenderer = useCallback(() => {\n      if (!canvas.current) return\n\n      const height = canvas.current.offsetHeight\n      const width = canvas.current.offsetWidth\n\n      Common.setDecomp(require(\"poly-decomp\"))\n\n      // Remove default gravity\n      engine.current.gravity.x = 0\n      engine.current.gravity.y = 0\n\n      render.current = Render.create({\n        element: canvas.current,\n        engine: engine.current,\n        options: {\n          width,\n          height,\n          wireframes: false,\n          background: \"#00000000\",\n        },\n      })\n\n      // Add walls\n      const walls = [\n        // Floor\n        Bodies.rectangle(width / 2, height + 10, width, 20, {\n          isStatic: true,\n          friction: 1,\n          render: {\n            visible: debug,\n          },\n        }),\n\n        // Right wall\n        Bodies.rectangle(width + 10, height / 2, 20, height, {\n          isStatic: true,\n          friction: 1,\n          render: {\n            visible: debug,\n          },\n        }),\n\n        // Left wall\n        Bodies.rectangle(-10, height / 2, 20, height, {\n          isStatic: true,\n          friction: 1,\n          render: {\n            visible: debug,\n          },\n        }),\n      ]\n\n      const topWall = addTopWall\n        ? Bodies.rectangle(width / 2, -10, width, 20, {\n            isStatic: true,\n            friction: 1,\n            render: {\n              visible: debug,\n            },\n          })\n        : null\n\n      if (topWall) {\n        walls.push(topWall)\n      }\n\n      World.add(engine.current.world, [...walls])\n\n      runner.current = Runner.create()\n      Render.run(render.current)\n      updateElements()\n      runner.current.enabled = false\n\n      if (autoStart) {\n        runner.current.enabled = true\n        startEngine()\n      }\n\n      // Add force application before update\n      Events.on(engine.current, \"beforeUpdate\", () => {\n        const bodies = engine.current.world.bodies.filter(\n          (body) => !body.isStatic\n        )\n\n        // Calculate attractor position in pixels\n        const attractorX = typeof attractorPoint.x === 'string' \n          ? (width * parseFloat(attractorPoint.x) / 100)\n          : width * attractorPoint.x\n        const attractorY = typeof attractorPoint.y === 'string'\n          ? (height * parseFloat(attractorPoint.y) / 100) \n          : height * attractorPoint.y\n\n        bodies.forEach((body) => {\n          // Apply attractor force\n          const dx = attractorX - body.position.x\n          const dy = attractorY - body.position.y\n          const distance = Math.sqrt(dx * dx + dy * dy)\n\n          if (distance > 0) {\n            const force = {\n              x: (dx / distance) * attractorStrength * body.mass,\n              y: (dy / distance) * attractorStrength * body.mass,\n            }\n            Body.applyForce(body, body.position, force)\n          }\n\n          // Apply cursor force if mouse is present\n          if (mouseRef.current?.x && mouseRef.current?.y && mouseRef.current.x > 0 && mouseRef.current.y > 0) {\n            const mdx = mouseRef.current.x - body.position.x\n            const mdy = mouseRef.current.y - body.position.y\n            const mouseDistance = Math.sqrt(mdx * mdx + mdy * mdy)\n\n            if (mouseDistance > 0 && mouseDistance < cursorFieldRadius) {\n              const mouseForce = {\n                x: (mdx / mouseDistance) * cursorStrength * body.mass,\n                y: (mdy / mouseDistance) * cursorStrength * body.mass,\n              }\n              Body.applyForce(body, body.position, mouseForce)\n            }\n          }\n        })\n      })\n    }, [updateElements, debug, autoStart, attractorPoint, attractorStrength, cursorStrength])\n\n    // Clear the Matter.js world\n    const clearRenderer = useCallback(() => {\n      if (frameId.current) {\n        cancelAnimationFrame(frameId.current)\n      }\n\n      if (render.current) {\n        Render.stop(render.current)\n        render.current.canvas.remove()\n      }\n\n      if (runner.current) {\n        Runner.stop(runner.current)\n      }\n\n      if (engine.current) {\n        World.clear(engine.current.world, false)\n        Engine.clear(engine.current)\n      }\n\n      bodiesMap.current.clear()\n    }, [])\n\n    const handleResize = useCallback(() => {\n      if (!canvas.current || !resetOnResize) return\n\n      const newWidth = canvas.current.offsetWidth\n      const newHeight = canvas.current.offsetHeight\n\n      setCanvasSize({ width: newWidth, height: newHeight })\n\n      // Clear and reinitialize\n      clearRenderer()\n      initializeRenderer()\n    }, [clearRenderer, initializeRenderer, resetOnResize])\n\n    const startEngine = useCallback(() => {\n      if (runner.current) {\n        runner.current.enabled = true\n\n        Runner.run(runner.current, engine.current)\n      }\n      if (render.current) {\n        Render.run(render.current)\n      }\n      frameId.current = requestAnimationFrame(updateElements)\n      isRunning.current = true\n    }, [updateElements, canvasSize])\n\n    const stopEngine = useCallback(() => {\n      if (!isRunning.current) return\n\n      if (runner.current) {\n        Runner.stop(runner.current)\n      }\n      if (render.current) {\n        Render.stop(render.current)\n      }\n      if (frameId.current) {\n        cancelAnimationFrame(frameId.current)\n      }\n      isRunning.current = false\n    }, [])\n\n    const reset = useCallback(() => {\n      stopEngine()\n      bodiesMap.current.forEach(({ element, body, props }) => {\n        body.angle = props.angle || 0\n\n        const x = calculatePosition(\n          props.x,\n          canvasSize.width,\n          element.offsetWidth\n        )\n        const y = calculatePosition(\n          props.y,\n          canvasSize.height,\n          element.offsetHeight\n        )\n        body.position.x = x\n        body.position.y = y\n      })\n      updateElements()\n      handleResize()\n    }, [])\n\n    useImperativeHandle(\n      ref,\n      () => ({\n        start: startEngine,\n        stop: stopEngine,\n        reset,\n      }),\n      [startEngine, stopEngine]\n    )\n\n    useEffect(() => {\n      if (!resetOnResize) return\n\n      const debouncedResize = debounce(handleResize, 500)\n      window.addEventListener(\"resize\", debouncedResize)\n\n      return () => {\n        window.removeEventListener(\"resize\", debouncedResize)\n        debouncedResize.cancel()\n      }\n    }, [handleResize, resetOnResize])\n\n    useEffect(() => {\n      initializeRenderer()\n      return clearRenderer\n    }, [initializeRenderer, clearRenderer])\n\n    return (\n      <GravityContext.Provider value={{ registerElement, unregisterElement }}>\n        <div\n          ref={canvas}\n          className={cn(className, \"absolute top-0 left-0 w-full h-full\")}\n          {...props}\n        >\n          {children}\n        </div>\n      </GravityContext.Provider>\n    )\n  }\n)\n\nGravity.displayName = \"Gravity\"\nexport default Gravity\n",
      "type": "registry:ui",
      "target": "components/fancy/physics/cursor-attractor-and-gravity.tsx"
    }
  ]
}