{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "box-carousel",
  "type": "registry:ui",
  "dependencies": [
    "motion"
  ],
  "author": "daniel petho <https://www.danielpetho.com>",
  "registryDependencies": [
    "https://uwuui.com/r/utils.json"
  ],
  "files": [
    {
      "path": "fancy/carousel/box-carousel.tsx",
      "content": "\"use client\"\n\nimport React, {\n  forwardRef,\n  memo,\n  ReactNode,\n  useCallback,\n  useEffect,\n  useImperativeHandle,\n  useMemo,\n  useRef,\n  useState,\n} from \"react\"\nimport {\n  animate,\n  motion,\n  useMotionValue,\n  useReducedMotion,\n  useSpring,\n  useTransform,\n  ValueAnimationOptions,\n} from \"motion/react\"\n\nimport { cn } from \"@/lib/utils\"\n\ninterface CarouselItem {\n  /**\n   * Unique identifier for the carousel item\n   */\n  id: string\n  /**\n   * The type of media: \"image\" or \"video\"\n   */\n  type: \"image\" | \"video\"\n  /**\n   * Source URL for the image or video\n   */\n  src: string\n  /**\n   * (Optional) Alternative text for images\n   */\n  alt?: string\n  /**\n   * (Optional) Poster image for videos (displayed before playback)\n   */\n  poster?: string\n}\n\n/**\n * Props for a single face of the cube in the BoxCarousel.\n */\ninterface FaceProps {\n  /**\n   * The CSS transform string to position and rotate the face in 3D space.\n   */\n  transform: string\n  /**\n   * Optional additional CSS class names for the face.\n   */\n  className?: string\n  /**\n   * Optional React children to render inside the face.\n   */\n  children?: ReactNode\n  /**\n   * Optional inline styles for the face.\n   */\n  style?: React.CSSProperties\n  /**\n   * If true, enables debug mode (e.g., shows backface and opacity).\n   */\n  debug?: boolean\n}\n\nconst CubeFace = memo(\n  ({ transform, className, children, style, debug }: FaceProps) => (\n    <div\n      className={cn(\n        \"absolute overflow-hidden\",\n        debug && \"backface-visible opacity-50\",\n        className\n      )}\n      style={{ transform, ...style }}\n    >\n      {children}\n    </div>\n  )\n)\n\nCubeFace.displayName = \"CubeFace\"\n\nconst MediaRenderer = memo(\n  ({\n    item,\n    className,\n    debug = false,\n  }: {\n    item: CarouselItem\n    className?: string\n    debug?: boolean\n  }) => {\n    if (!debug) {\n      if (item.type === \"video\") {\n        return (\n          <video\n            src={item.src}\n            poster={item.poster}\n            className={cn(\"w-full h-full object-cover\", className)}\n            muted\n            loop\n            autoPlay\n          />\n        )\n      }\n\n      return (\n        <img\n          src={item.src}\n          alt={item.alt || \"\"}\n          draggable={false}\n          className={cn(\"w-full h-full object-cover\", className)}\n        />\n      )\n    }\n\n    return (\n      <div\n        className={cn(\n          \"w-full h-full flex items-center justify-center border text-2xl\",\n          className\n        )}\n      >\n        {item.id}\n      </div>\n    )\n  }\n)\n\nMediaRenderer.displayName = \"MediaRenderer\"\n\nexport interface BoxCarouselRef {\n  /**\n   * Advance to the next item in the carousel.\n   */\n  next: () => void\n\n  /**\n   * Go back to the previous item in the carousel.\n   */\n  prev: () => void\n\n  /**\n   * Get the index of the currently visible item.\n   */\n  getCurrentItemIndex: () => number\n}\n\ntype RotationDirection = \"top\" | \"bottom\" | \"left\" | \"right\"\n\ninterface SpringConfig {\n  stiffness?: number\n  damping?: number\n  mass?: number\n}\n\n/**\n * Props for the BoxCarousel component\n */\ninterface BoxCarouselProps extends React.HTMLProps<HTMLDivElement> {\n  /**\n   * Array of items to display in the carousel\n   */\n  items: CarouselItem[]\n\n  /**\n   * Width of the carousel in pixels\n   */\n  width: number\n\n  /**\n   * Height of the carousel in pixels\n   */\n  height: number\n\n  /**\n   * Additional CSS classes for the container\n   */\n  className?: string\n\n  /**\n   * Enable debug mode (shows extra info/overlays)\n   */\n  debug?: boolean\n\n  /**\n   * Perspective value for 3D effect (in px)\n   * @default 600\n   */\n  perspective?: number\n\n  /**\n   * The axis and direction of rotation\n   * @default \"vertical\"\n   * \"top\" | \"bottom\" | \"left\" | \"right\"\n   */\n  direction?: RotationDirection\n\n  /**\n   * Transition configuration for rotation animation\n   * @default { duration: 1.25, ease: [0.953, 0.001, 0.019, 0.995] }\n   */\n  transition?: ValueAnimationOptions\n\n  /**\n   * Transition configuration for snapping after drag\n   * @default { type: \"spring\", damping: 30, stiffness: 200 }\n   */\n  snapTransition?: ValueAnimationOptions\n\n  /**\n   * Spring physics config for drag interaction\n   * @default { stiffness: 200, damping: 30 }\n   */\n  dragSpring?: SpringConfig\n\n  /**\n   * Enable auto-play mode\n   * @default false\n   */\n  autoPlay?: boolean\n\n  /**\n   * Interval (ms) between auto-play transitions\n   * @default 3000\n   */\n  autoPlayInterval?: number\n\n  /**\n   * Callback when the current item index changes\n   */\n  onIndexChange?: (index: number) => void\n\n  /**\n   * Enable drag interaction\n   * @default true\n   */\n  enableDrag?: boolean\n\n  /**\n   * Sensitivity of drag (higher = more rotation per pixel)\n   * @default 0.5\n   */\n  dragSensitivity?: number\n}\n\nconst BoxCarousel = forwardRef<BoxCarouselRef, BoxCarouselProps>(\n  (\n    {\n      items,\n      width,\n      height,\n      className,\n      perspective = 600,\n      debug = false,\n      direction = \"left\",\n      transition = { duration: 1.25, ease: [0.953, 0.001, 0.019, 0.995] },\n      snapTransition = { type: \"spring\", damping: 30, stiffness: 200 },\n      dragSpring = { stiffness: 200, damping: 30 },\n      autoPlay = false,\n      autoPlayInterval = 3000,\n      onIndexChange,\n      enableDrag = true,\n      dragSensitivity = 0.5,\n      ...props\n    },\n    ref\n  ) => {\n    const [currentItemIndex, setCurrentItemIndex] = useState(0)\n    const [currentFrontFaceIndex, setCurrentFrontFaceIndex] = useState(1)\n\n    const prefersReducedMotion = useReducedMotion()\n\n    const _transition = prefersReducedMotion ? { duration: 0 } : transition\n\n    // 0 ⇢ will be shown if the user presses \"prev\"\n    const [prevIndex, setPrevIndex] = useState(items.length - 1)\n\n    // 1 ⇢ item that is currently visible\n    const [currentIndex, setCurrentIndex] = useState(0)\n\n    // 2 ⇢ will be shown on the next \"next\"\n    const [nextIndex, setNextIndex] = useState(1)\n\n    // 3 ⇢ two steps ahead (the face that is at the back right now)\n    const [afterNextIndex, setAfterNextIndex] = useState(2)\n\n    const [currentRotation, setCurrentRotation] = useState(0)\n\n    const rotationCount = useRef(1)\n    const isRotating = useRef(false)\n    const pendingIndexChange = useRef<number | null>(null)\n    const isDragging = useRef(false)\n    const startPosition = useRef({ x: 0, y: 0 })\n    const startRotation = useRef(0)\n\n    const baseRotateX = useMotionValue(0)\n    const baseRotateY = useMotionValue(0)\n\n    // Use springs for smoother animation during drag\n    const springRotateX = useSpring(baseRotateX, dragSpring)\n    const springRotateY = useSpring(baseRotateY, dragSpring)\n\n    const handleAnimationComplete = useCallback(\n      (triggeredBy: string) => {\n        if (isRotating.current && pendingIndexChange.current !== null) {\n          isRotating.current = false\n\n          let newFrontFaceIndex: number\n          let currentBackFaceIndex: number\n\n          if (triggeredBy === \"next\") {\n            newFrontFaceIndex = (currentFrontFaceIndex + 1) % 4\n            currentBackFaceIndex = (newFrontFaceIndex + 2) % 4\n          } else {\n            newFrontFaceIndex = (currentFrontFaceIndex - 1 + 4) % 4\n            currentBackFaceIndex = (newFrontFaceIndex + 3) % 4\n          }\n\n          setCurrentItemIndex(pendingIndexChange.current)\n          onIndexChange?.(pendingIndexChange.current)\n\n          const indexOffset = triggeredBy === \"next\" ? 2 : -1\n\n          if (currentBackFaceIndex === 0) {\n            setPrevIndex(\n              (pendingIndexChange.current + indexOffset + items.length) %\n                items.length\n            )\n          } else if (currentBackFaceIndex === 1) {\n            setCurrentIndex(\n              (pendingIndexChange.current + indexOffset + items.length) %\n                items.length\n            )\n          } else if (currentBackFaceIndex === 2) {\n            setNextIndex(\n              (pendingIndexChange.current + indexOffset + items.length) %\n                items.length\n            )\n          } else if (currentBackFaceIndex === 3) {\n            setAfterNextIndex(\n              (pendingIndexChange.current + indexOffset + items.length) %\n                items.length\n            )\n          }\n\n          pendingIndexChange.current = null\n          rotationCount.current++\n\n          setCurrentFrontFaceIndex(newFrontFaceIndex)\n        }\n      },\n      [currentFrontFaceIndex, items.length, onIndexChange]\n    )\n\n    // Drag functionality - using direct event handlers like css-box\n    const handleDragStart = useCallback(\n      (e: React.MouseEvent | React.TouchEvent) => {\n        if (!enableDrag || isRotating.current) return\n\n        isDragging.current = true\n        const point = \"touches\" in e ? e.touches[0] : e\n        startPosition.current = { x: point.clientX, y: point.clientY }\n        startRotation.current = currentRotation\n\n        // Prevent default to avoid text selection\n        e.preventDefault()\n      },\n      [enableDrag, currentRotation]\n    )\n\n    const handleDragMove = useCallback(\n      (e: MouseEvent | TouchEvent) => {\n        if (!isDragging.current || isRotating.current) return\n\n        const point = \"touches\" in e ? e.touches[0] : e\n        const deltaX = point.clientX - startPosition.current.x\n        const deltaY = point.clientY - startPosition.current.y\n\n        const isVertical = direction === \"top\" || direction === \"bottom\"\n        const delta = isVertical ? deltaY : deltaX\n        const rotationDelta = (delta * dragSensitivity) / 2\n\n        let newRotation = startRotation.current\n\n        if (direction === \"top\" || direction === \"right\") {\n          newRotation += rotationDelta\n        } else {\n          newRotation -= rotationDelta\n        }\n\n        // Constrain rotation to ±120 degrees from start position. Otherwise the index recalculation will be off. TBD - find a better solution\n        const minRotation = startRotation.current - 120\n        const maxRotation = startRotation.current + 120\n        newRotation = Math.max(minRotation, Math.min(maxRotation, newRotation))\n\n        // Apply the rotation immediately during drag\n        if (isVertical) {\n          baseRotateX.set(newRotation)\n        } else {\n          baseRotateY.set(newRotation)\n        }\n      },\n      [enableDrag, direction, dragSensitivity]\n    )\n\n    const handleDragEnd = useCallback(() => {\n      if (!isDragging.current) return\n\n      isDragging.current = false\n\n      const isVertical = direction === \"top\" || direction === \"bottom\"\n      const currentValue = isVertical ? baseRotateX.get() : baseRotateY.get()\n\n      // Calculate the nearest quarter rotation (90-degree increment)\n      const quarterRotations = Math.round(currentValue / 90)\n      const snappedRotation = quarterRotations * 90\n\n      // Calculate how many steps we've moved from the original position\n      const rotationDifference = snappedRotation - currentRotation\n      const steps = Math.round(rotationDifference / 90)\n\n      if (steps !== 0) {\n        isRotating.current = true\n\n        // Calculate new item index\n        let newItemIndex = currentItemIndex\n        for (let i = 0; i < Math.abs(steps); i++) {\n          if (steps > 0) {\n            newItemIndex = (newItemIndex + 1) % items.length\n          } else {\n            newItemIndex =\n              newItemIndex === 0 ? items.length - 1 : newItemIndex - 1\n          }\n        }\n\n        pendingIndexChange.current = newItemIndex\n\n        // Animate to the snapped position\n        const targetMotionValue = isVertical ? baseRotateX : baseRotateY\n        animate(targetMotionValue, snappedRotation, {\n          ...snapTransition,\n          onComplete: () => {\n            handleAnimationComplete(steps > 0 ? \"next\" : \"prev\")\n            setCurrentRotation(snappedRotation)\n          },\n        })\n      } else {\n        // Snap back to current position\n        const targetMotionValue = isVertical ? baseRotateX : baseRotateY\n        animate(targetMotionValue, currentRotation, snapTransition)\n      }\n    }, [\n      direction,\n      baseRotateX,\n      baseRotateY,\n      currentRotation,\n      currentItemIndex,\n      items.length,\n      transition,\n      handleAnimationComplete,\n    ])\n\n    // Set up global event listeners for drag\n    useEffect(() => {\n      if (enableDrag) {\n        window.addEventListener(\"mousemove\", handleDragMove)\n        window.addEventListener(\"mouseup\", handleDragEnd)\n        window.addEventListener(\"touchmove\", handleDragMove)\n        window.addEventListener(\"touchend\", handleDragEnd)\n\n        return () => {\n          window.removeEventListener(\"mousemove\", handleDragMove)\n          window.removeEventListener(\"mouseup\", handleDragEnd)\n          window.removeEventListener(\"touchmove\", handleDragMove)\n          window.removeEventListener(\"touchend\", handleDragEnd)\n        }\n      }\n    }, [enableDrag, handleDragMove, handleDragEnd])\n\n    const next = useCallback(() => {\n      if (items.length === 0 || isRotating.current) return\n\n      isRotating.current = true\n      const newIndex = (currentItemIndex + 1) % items.length\n      pendingIndexChange.current = newIndex\n\n      if (direction === \"top\") {\n        animate(baseRotateX, currentRotation + 90, {\n          ..._transition,\n          onComplete: () => {\n            handleAnimationComplete(\"next\")\n            setCurrentRotation(currentRotation + 90)\n          },\n        })\n      } else if (direction === \"bottom\") {\n        animate(baseRotateX, currentRotation - 90, {\n          ..._transition,\n          onComplete: () => {\n            handleAnimationComplete(\"next\")\n            setCurrentRotation(currentRotation - 90)\n          },\n        })\n      } else if (direction === \"left\") {\n        animate(baseRotateY, currentRotation - 90, {\n          ..._transition,\n          onComplete: () => {\n            handleAnimationComplete(\"next\")\n            setCurrentRotation(currentRotation - 90)\n          },\n        })\n      } else if (direction === \"right\") {\n        animate(baseRotateY, currentRotation + 90, {\n          ..._transition,\n          onComplete: () => {\n            handleAnimationComplete(\"next\")\n            setCurrentRotation(currentRotation + 90)\n          },\n        })\n      }\n    }, [items.length, direction, transition, currentRotation])\n\n    const prev = useCallback(() => {\n      if (items.length === 0 || isRotating.current) return\n\n      isRotating.current = true\n      const newIndex =\n        currentItemIndex === 0 ? items.length - 1 : currentItemIndex - 1\n      pendingIndexChange.current = newIndex\n\n      if (direction === \"top\") {\n        animate(baseRotateX, currentRotation - 90, {\n          ..._transition,\n          onComplete: () => {\n            handleAnimationComplete(\"prev\")\n            setCurrentRotation(currentRotation - 90)\n          },\n        })\n      } else if (direction === \"bottom\") {\n        animate(baseRotateX, currentRotation + 90, {\n          ..._transition,\n          onComplete: () => {\n            handleAnimationComplete(\"prev\")\n            setCurrentRotation(currentRotation + 90)\n          },\n        })\n      } else if (direction === \"left\") {\n        animate(baseRotateY, currentRotation + 90, {\n          ..._transition,\n          onComplete: () => {\n            handleAnimationComplete(\"prev\")\n            setCurrentRotation(currentRotation + 90)\n          },\n        })\n      } else if (direction === \"right\") {\n        animate(baseRotateY, currentRotation - 90, {\n          ..._transition,\n          onComplete: () => {\n            handleAnimationComplete(\"prev\")\n            setCurrentRotation(currentRotation - 90)\n          },\n        })\n      }\n    }, [items.length, direction, transition])\n\n    useImperativeHandle(\n      ref,\n      () => ({\n        next,\n        prev,\n        getCurrentItemIndex: () => currentItemIndex,\n      }),\n      [next, prev, currentItemIndex]\n    )\n\n    const depth = useMemo(\n      () => (direction === \"top\" || direction === \"bottom\" ? height : width),\n      [direction, width, height]\n    )\n\n    const transform = useTransform(\n      isDragging.current\n        ? [springRotateX, springRotateY]\n        : [baseRotateX, baseRotateY],\n      ([x, y]) =>\n        `translateZ(-${depth / 2}px) rotateX(${x}deg) rotateY(${y}deg)`\n    )\n\n    // Determine face transforms based on the desired rotation axis\n    const faceTransforms = (() => {\n      switch (direction) {\n        case \"left\":\n          return [\n            // left, front, right, back (rotation around Y-axis)\n            `rotateY(-90deg) translateZ(${width / 2}px)`,\n            `rotateY(0deg) translateZ(${depth / 2}px)`,\n            `rotateY(90deg) translateZ(${width / 2}px)`,\n            `rotateY(180deg) translateZ(${depth / 2}px)`,\n          ]\n        case \"top\":\n          return [\n            // top, front, bottom, back (rotation around X-axis)\n            `rotateX(90deg) translateZ(${height / 2}px)`,\n            `rotateY(0deg) translateZ(${depth / 2}px)`,\n            `rotateX(-90deg) translateZ(${height / 2}px)`,\n            `rotateY(180deg) translateZ(${depth / 2}px) rotateZ(180deg)`,\n          ]\n        case \"right\":\n          return [\n            // right, front, left, back (rotation around Y-axis)\n            `rotateY(90deg) translateZ(${width / 2}px)`,\n            `rotateY(0deg) translateZ(${depth / 2}px)`,\n            `rotateY(-90deg) translateZ(${width / 2}px)`,\n            `rotateY(180deg) translateZ(${depth / 2}px)`,\n          ]\n        case \"bottom\":\n          return [\n            // bottom, front, top, back (rotation around X-axis)\n            `rotateX(-90deg) translateZ(${height / 2}px)`,\n            `rotateY(0deg) translateZ(${depth / 2}px)`,\n            `rotateX(90deg) translateZ(${height / 2}px)`,\n            `rotateY(180deg) translateZ(${depth / 2}px) rotateZ(180deg)`,\n          ]\n        default:\n          return [\n            // left, front, right, back (rotation around Y-axis)\n            `rotateY(-90deg) translateZ(${width / 2}px)`,\n            `rotateY(0deg) translateZ(${depth / 2}px)`,\n            `rotateY(90deg) translateZ(${width / 2}px)`,\n            `rotateY(180deg) translateZ(${depth / 2}px)`,\n          ]\n      }\n    })()\n\n    // Auto play functionality\n    useEffect(() => {\n      if (autoPlay && items.length > 0) {\n        const interval = setInterval(next, autoPlayInterval)\n        return () => clearInterval(interval)\n      }\n    }, [autoPlay, items.length, next, autoPlayInterval])\n\n    const handleKeyDown = useCallback(\n      (e: React.KeyboardEvent) => {\n        if (isRotating.current) return\n\n        switch (e.key) {\n          case \"ArrowLeft\":\n            e.preventDefault()\n            if (direction === \"left\" || direction === \"right\") {\n              prev()\n            }\n            break\n          case \"ArrowRight\":\n            e.preventDefault()\n            if (direction === \"left\" || direction === \"right\") {\n              next()\n            }\n            break\n          case \"ArrowUp\":\n            e.preventDefault()\n            if (direction === \"top\" || direction === \"bottom\") {\n              prev()\n            }\n            break\n          case \"ArrowDown\":\n            e.preventDefault()\n            if (direction === \"top\" || direction === \"bottom\") {\n              next()\n            }\n            break\n          default:\n            break\n        }\n      },\n      [direction, next, prev, items.length]\n    )\n\n    return (\n      <div\n        className={cn(\"relative focus:outline-0\", enableDrag && \"cursor-move\", className)}\n        style={{\n          width,\n          height,\n          perspective: `${perspective}px`,\n        }}\n        onKeyDown={handleKeyDown}\n        tabIndex={0}\n        aria-label={`3D carousel with ${items.length} items`}\n        aria-describedby=\"carousel-instructions\"\n        aria-live=\"polite\"\n        aria-atomic=\"true\"\n        onMouseDown={handleDragStart}\n        onTouchStart={handleDragStart}\n        {...props}\n      >\n        <div className=\"sr-only\" aria-live=\"assertive\">\n          Showing item {currentItemIndex + 1} of {items.length}:{\" \"}\n          {items[currentItemIndex]?.alt || `Item ${currentItemIndex + 1}`}\n        </div>\n\n        <motion.div\n          className=\"relative w-full h-full [transform-style:preserve-3d]\"\n          style={{\n            transform: transform,\n          }}\n        >\n          {/* First face */}\n          <CubeFace\n            transform={faceTransforms[0]}\n            style={\n              debug\n                ? { width, height, backgroundColor: \"#ff9999\" }\n                : { width, height }\n            }\n            debug={debug}\n          >\n            <MediaRenderer item={items[prevIndex]} debug={debug} />\n          </CubeFace>\n\n          {/* Second face */}\n          <CubeFace\n            transform={faceTransforms[1]}\n            style={\n              debug\n                ? { width, height, backgroundColor: \"#99ff99\" }\n                : { width, height }\n            }\n            debug={debug}\n          >\n            <MediaRenderer item={items[currentIndex]} debug={debug} />\n          </CubeFace>\n\n          {/* Third face */}\n          <CubeFace\n            transform={faceTransforms[2]}\n            style={\n              debug\n                ? { width, height, backgroundColor: \"#9999ff\" }\n                : { width, height }\n            }\n            debug={debug}\n          >\n            <MediaRenderer item={items[nextIndex]} debug={debug} />\n          </CubeFace>\n\n          {/* Fourth face */}\n          <CubeFace\n            transform={faceTransforms[3]}\n            style={\n              debug\n                ? { width, height, backgroundColor: \"#ffff99\" }\n                : { width, height }\n            }\n            debug={debug}\n          >\n            <MediaRenderer item={items[afterNextIndex]} debug={debug} />\n          </CubeFace>\n        </motion.div>\n      </div>\n    )\n  }\n)\n\nBoxCarousel.displayName = \"BoxCarousel\"\n\nexport default BoxCarousel\nexport type { CarouselItem, RotationDirection, SpringConfig }\n",
      "type": "registry:ui",
      "target": "components/fancy/carousel/box-carousel.tsx"
    }
  ]
}